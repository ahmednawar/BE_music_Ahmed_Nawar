Describe in a high level the solution you have in mind
> The solution I have in mind would sort songs by their relevance to a specific user. For a given music **_M_**, its relevance **_R_** would be based on three factors: <br />
  **_N_**: whether the song is new to the user <br /> 
  **_G_**: whether its genres are amongst the user's favorites, <br />
  **_F_**: and number of followees who listened to it before .<br />

> To maximize a song’s relevance to a user, **_N_** should be fullfilled, **_G_** and **_F_** should be maximized.

> the formula I am using is:

>       R(M) = 25 N(M) x (10 G(M) + 5 F(M))

> _N(M)_ = if playbackCount(M) = 0, return 1 else return 0;

> Since the emphasis is on discovery of new songs, a previously heard song receives a score of 0 and music novelty gets the highest coefficient. 

> _G(M)_ is the arithmetic mean of the genres score of _M_ related to the user. for a given genre _g_ and user _u_, its score is: (number of songs listened by _u_ that belong to _g_) / (total number of songs listened by _u_). if _G(M)_ is zero, I return a small constant _(0.1)_ in case the user is still new and didn’t listen to much music.

> _F(M)_ = (number of followees who listened to _M_) / (total number of followees) 


What other data could you use to improve recommendations?
> The data can be split into 2 broad categories:<br />
* Music related:
  * Artist, release date, language, country of origin
  * Ratings by users(likes and dislikes, 5 stars)
  * Analysis of the music attributes similar to Pandora such as tonality, tempo, rhythm, vocal harmony, etc
  * Users can assign a 'mood' to songs: happy, sad, depressing, relaxing, etc. which are then aggregated and assigned as tags to the songs 
  * Trending songs and genres.
* User related:
  * Each user gets a rank based on how many followers they have, time spent on site, how many songs they listen to which will affect recommendations based on followees.
  * The user can also choose their current mood which would make use of the aformentioned song mood feature.


Assume a more real world situation where you could have more data you described above, and more time to implement, could you think of a possibly more efficient way to recommend?
> I could employ the following techniques to better the recommendation scheme:<br />
* I will take into account the data mementioned above to have a more representative and sophisticated scoring formula.
* Use Machine Learning and Data Mining techniques like binary classifiers based on the user likes and dislikes of songs presented to them. Using various learning models, the engine can infer the user's taste and recommend songs more accurately.
* Rather than computing the reccommended music list every time the user asks for a recommendation, I will cache the top 20 results for a specific time period. During this period, any subsequent recommendation request will be served from this temporary list.
* I will create reverse indices for the music list (e.g. genres to musics).Rather than iterating over the entire music list, I can narrow the search space to specific attributes (e.g genres) the user specified/interested in and trending ones, since these are much faster to compute. 
* For very large lists, I can introduce randomization. Rather than processing an entire list sequentially, I will only process a subset of the list chosen randomly. 

Assume you have more than one implementation of recommendations, how could you test which one is more effective using data generated by user actions?
> I can present each implementation to the users for a specific period of time and measure their activity. Also, I can split the users into several groups where each one is presented with a different implementation. 
I will track the following metrics:<br />
* Number of likes and dislikes (or the equivalent if a 5-star based rating system)
* Number of songs played, number of songs listened until the end, and number of songs playedmore than once.
* Number of songs shared via fb, twitter, etc or if the website itself was shared.
* Average time spent on the website.
* For each song, track how the user found it (recommended, search, friends feed, link on social networking websites) 

--

How long did this assignment take? Please be honest it's relativelly new.
> ~37 hours split over 13 days. This doesn't include 8-9 days of doing some research on JavaScript, Node.JS, Express and MongoDB before tackling the assignment.  

Where would be the bottlenecks of this solution you have implemented?
> * Iterating over the entire music list for each recommendation request 
  * For a given recommendation request, I load followees data to RAM if they aren't already. This can be a waste of memory if they aren't needed later on given that I am only interested in their music list not their entire data.


What was the hardest part?
> Thinking asynchronously. Although the concept might be simple in theory, getting comfortable with this paradigm and structuring the code accordignly was challenging. 

Did you learn something new?
> Basically everything I did in this assignment was new except using the terminal :) It was great though getting out of the the low-level bat cave!

Do you feel your skills were under tested?
> Yeah. I had to learn a lot of new concepts and technologies at a fast pace. Also, it tested my mental flexibility because I had to approach problems with a different mindset, which was dictated by the platforms used (e.g. asynchrnous paradigm, closures and hoisting in JS). 